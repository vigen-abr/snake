{"version":3,"sources":["scripts/Snake/components/Pixel/Pixel.js","scripts/Snake/components/TargetPixel/TargetPixel.js","scripts/Snake/Game.tsx","scripts/Snake/helpers/dataObjects.tsx","App.js","serviceWorker.js","index.js"],"names":["Pixel","props","react_default","a","createElement","className","style","top","concat","left","width","size","height","TargetPixel","DIRECTION","initialLeft","initialPixelIndex","initialTargetIndex","createPixel","_index","getRandomInt","min","max","Math","ceil","floor","random","Game","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","moveIntervalId","targetsIntervalId","ongoingDirection","pixels","targets","direction","RIGHT","gameOver","handleKeyDown","bind","assertThisInitialized","document","addEventListener","react","PIXEL_SIZE","map","px","idx","components_Pixel_Pixel","key","tg","components_TargetPixel_TargetPixel","event","preventDefault","_mapEventToDirection","correct","UP","reverse","DOWN","LEFT","_initFirstPixel","setIntervals","toConsumableArray","unshift","setState","_this2","res","reduce","acc","currentPixel","current","objectSpread","previous","_movePixel","push","headPixel","_hasBorderConflict","_onGameOver","_hasSelfConflict","length","hasTargets","hitTargetIndex","_hitTheTarget","onTargetHit","targetIndex","splice","window","clearInterval","removeEventListener","hedPixel","some","pixel","findIndex","nextTarget","Error","_this3","setInterval","_updateDirection","_updatePixelPositions","needsTarget","_generateValidTarget","areaSize","target","console","log","_isValidTarget","newTarget","React","App","scripts_Snake_Game","Boolean","location","hostname","match","ReactDOM","render","src_App","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.67ad9445.chunk.js","sourcesContent":["import React from 'react';\nimport './Pixel.scss';\n\nfunction Pixel(props) {\n  return (\n    <div className=\"game-wrapper__pixel\" style={{top: `${props.top}px`, left: `${props.left}px`, width: `${props.size}px`, height: `${props.size}px`}}>\n    </div>\n  );\n}\n\nexport default Pixel;\n","import React from 'react';\nimport './TargetPixel.scss';\n\nfunction TargetPixel(props) {\n  return (\n    <div className=\"game-wrapper__target-pixel\" style={{top: `${props.top}px`, left: `${props.left}px`, width: `${props.size}px`, height: `${props.size}px`}}>\n    </div>\n  );\n}\n\nexport default TargetPixel;\n","import * as React from 'react';\nimport './Game.scss';\nimport Pixel from './components/Pixel/Pixel';\nimport TargetPixel from './components/TargetPixel/TargetPixel';\nimport {createPixel, createTarget} from './helpers/dataObjects';\nimport {pixelObject, targetObject} from \"../../typings/Snake/helpers/dataObjects.d\";\n\nenum DIRECTION {\n    UP = \"UP\",\n    DOWN = \"DOWN\",\n    LEFT = \"LEFT\",\n    RIGHT = \"RIGHT\"\n}\n\nconst PIXEL_SIZE = 20;\nconst AREA_SIZE = PIXEL_SIZE * 20;\n\ninterface props {\n}\n\ninterface state {\n    pixels: pixelObject[],\n    targets: targetObject[],\n    direction: DIRECTION,\n    gameOver: boolean\n}\n\nclass Game extends React.Component<props> {\n    public state: state;\n    private moveIntervalId: number | undefined;\n    private targetsIntervalId: number | undefined;\n    private ongoingDirection: { correct: DIRECTION, reverse: DIRECTION } | undefined;\n\n    constructor(props: props) {\n        super(props);\n        this.state = {\n            pixels: [],\n            targets: [],\n            direction: DIRECTION.RIGHT,\n            gameOver: false\n        };\n        this.handleKeyDown = this.handleKeyDown.bind(this);\n        document.addEventListener(\"keydown\", this.handleKeyDown);\n    }\n\n    render() {\n        return (<div className={`game-wrapper ${this.state.gameOver ? 'game-wrapper--game-over' : ''}`}\n                 style={{width: `${AREA_SIZE}px`, height: `${AREA_SIZE}px`}}>\n                {this.state.pixels.map((px: pixelObject, idx: number) => <Pixel key={idx} size={PIXEL_SIZE} top={px.top}\n                                                                                left={px.left}/>)}\n                {this.state.targets.map((tg: targetObject, idx: number) => <TargetPixel key={idx} size={PIXEL_SIZE}\n                                                                                        top={tg.top} left={tg.left}/>)}\n            </div>\n        );\n    }\n\n    handleKeyDown(event: KeyboardEvent): void {\n        event.preventDefault();\n        const direction = this._mapEventToDirection(event);\n        if (direction) {\n            this.ongoingDirection = direction;\n        }\n    }\n\n    _mapEventToDirection(event: KeyboardEvent): { correct: DIRECTION, reverse: DIRECTION } | false {\n        switch (event.key) {\n            case 'ArrowUp': {\n                return {\n                    correct: DIRECTION.UP,\n                    reverse: DIRECTION.DOWN\n                };\n            }\n            case 'ArrowRight': {\n                return {\n                    correct: DIRECTION.RIGHT,\n                    reverse: DIRECTION.LEFT\n                };\n            }\n            case 'ArrowDown': {\n                return {\n                    correct: DIRECTION.DOWN,\n                    reverse: DIRECTION.UP\n                };\n            }\n            case 'ArrowLeft': {\n                return {\n                    correct: DIRECTION.LEFT,\n                    reverse: DIRECTION.RIGHT\n                };\n            }\n            default: {\n                return false\n            }\n        }\n    }\n\n    componentDidMount() {\n        this._initFirstPixel();\n        this.setIntervals();\n    }\n\n    _initFirstPixel() {\n        const pixels = [...this.state.pixels];\n        pixels.unshift(createPixel(PIXEL_SIZE));\n        pixels.unshift(createPixel(PIXEL_SIZE));\n        pixels.unshift(createPixel(PIXEL_SIZE));\n        pixels.unshift(createPixel(PIXEL_SIZE));\n        pixels.unshift(createPixel(PIXEL_SIZE));\n        pixels.unshift(createPixel(PIXEL_SIZE));\n        pixels.unshift(createPixel(PIXEL_SIZE));\n\n        this.setState({pixels});\n    }\n\n    _updatePixelPositions(): void {\n        const oldPixels = [...this.state.pixels];\n        const res = oldPixels.reduce((acc: { previous?: pixelObject, pixels: pixelObject[] }, currentPixel) => {\n            let current = {...currentPixel};\n            if (acc.previous) {\n                let previous = {...acc.previous};\n                acc.previous = {...current};\n                current = {...current, top: previous.top, left: previous.left};\n\n            } else {\n                acc.previous = {...current};\n                this._movePixel(current);\n            }\n            acc.pixels.push(current);\n            return acc;\n        }, {pixels: []});\n\n        const headPixel = res.pixels[0];\n        if (this._hasBorderConflict(headPixel)) {\n            return this._onGameOver()\n        }\n        if (this._hasSelfConflict(headPixel)) {\n            return this._onGameOver();\n        }\n        if (this.state.targets.length) {\n\n        }\n        if (this.hasTargets) {\n            const hitTargetIndex = this._hitTheTarget(headPixel);\n            if (hitTargetIndex >= 0) {\n                this.onTargetHit(hitTargetIndex);\n\n            }\n        }\n        this.setState({pixels: res.pixels})\n\n\n    }\n\n    onTargetHit(targetIndex: number) {\n        const targets = [...this.state.targets];\n        //remove the hit target\n        targets.splice(targetIndex, 1);\n        this.setState({targets});\n    }\n\n    _updateDirection(): void {\n        if (this.ongoingDirection && this.ongoingDirection.reverse !== this.state.direction) {\n            this.setState({direction: this.ongoingDirection.correct});\n            delete this.ongoingDirection;\n        }\n    }\n\n    _onGameOver(): void {\n        this.setState({gameOver: true});\n        window.clearInterval(this.moveIntervalId);\n        window.clearInterval(this.targetsIntervalId);\n        document.removeEventListener(\"keydown\", this.handleKeyDown);\n    }\n\n    _hasBorderConflict(headPixel: pixelObject): boolean {\n        return (headPixel.top + PIXEL_SIZE > AREA_SIZE ||\n            headPixel.top < 0 ||\n            headPixel.left < 0 ||\n            headPixel.left + PIXEL_SIZE > AREA_SIZE);\n    }\n\n    _hasSelfConflict(hedPixel: pixelObject): boolean {\n        return this.state.pixels.some((pixel: pixelObject) => {\n            return pixel.top === hedPixel.top && pixel.left === hedPixel.left;\n        });\n    }\n\n    _hitTheTarget(headPixel: pixelObject): number {\n        return this.state.targets.findIndex((nextTarget: targetObject) => {\n            return nextTarget.top === headPixel.top && nextTarget.left === headPixel.left\n        });\n    }\n\n    _movePixel(pixel: pixelObject): pixelObject {\n        switch (this.state.direction) {\n            case DIRECTION.UP: {\n                pixel.top -= PIXEL_SIZE;\n                break;\n            }\n            case DIRECTION.RIGHT: {\n                pixel.left += PIXEL_SIZE;\n                break;\n            }\n            case DIRECTION.DOWN: {\n                pixel.top += PIXEL_SIZE;\n                break;\n            }\n            case DIRECTION.LEFT: {\n                pixel.left -= PIXEL_SIZE;\n                break;\n            }\n            default: {\n                throw new Error(`Unknown direction ${this.state.direction}`);\n            }\n        }\n        return pixel\n    }\n\n    setIntervals() {\n        this.moveIntervalId = window.setInterval(() => {\n            this._updateDirection();\n            this._updatePixelPositions();\n        }, 300);//todo add complexity\n        this.targetsIntervalId = window.setInterval(() => {\n            if (this.needsTarget) {\n                this.setState({targets: [...this.state.targets, this._generateValidTarget()]})\n            }\n        }, 500)\n    }\n\n    _generateValidTarget(): targetObject {\n        const target = createTarget(PIXEL_SIZE, AREA_SIZE);\n        console.log(target);\n        if (!this._isValidTarget(target)) {\n            return this._generateValidTarget()\n        }\n        return target;\n    }\n\n    _isValidTarget(newTarget: targetObject): boolean {\n        return !(this.state.pixels.some((pixel: pixelObject) => {\n            return pixel.top === newTarget.top && pixel.left === newTarget.left\n        }) || this.state.targets.some((target: targetObject) => {\n            return target.top === newTarget.top && target.left === newTarget.left\n        }))\n    }\n\n    get needsTarget(): boolean {\n        return Math.random() >= 0.9; //todo add complexity\n    }\n\n    get hasTargets(): boolean {\n        return !!this.state.targets.length;\n    }\n}\n\nexport default Game;\n","import {pixelObject, targetObject} from \"../../../typings/Snake/helpers/dataObjects.d\";\n\nlet initialLeft = 0;\nlet initialPixelIndex = 0;\nlet initialTargetIndex = 0;\n\nexport function createPixel(size: number): pixelObject {\n    return {\n        top: 0,\n        left: initialLeft += size,\n        _index: ++initialPixelIndex\n    }\n}\n\nexport function createTarget(size: number, areaSize: number): targetObject {\n    return {\n        top: getRandomInt(0, areaSize/size - 1) * size,\n        left: getRandomInt(0, areaSize/size - 1) * size,\n        _index: ++initialTargetIndex\n    }\n}\n\n\nfunction getRandomInt(min: number, max: number) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n","import React from 'react';\nimport './App.css';\nimport Game from './scripts/Snake/Game';\n\nfunction App() {\n  return (\n    <div className=\"app\">\n      <Game/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}