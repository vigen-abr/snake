{"version":3,"sources":["scripts/Snake/components/Pixel/Pixel.js","scripts/Snake/components/TargetPixel/TargetPixel.js","scripts/Snake/components/Complexity/Complexity.tsx","scripts/Snake/Game.tsx","scripts/Snake/helpers/dataObjects.tsx","App.js","serviceWorker.js","index.js"],"names":["Pixel","props","react_default","a","createElement","className","style","top","concat","left","width","size","height","TargetPixel","Complexity","DIRECTION","initialLeft","initialPixelIndex","initialTargetIndex","createPixel","origin","_index","getRandomInt","min","max","Math","ceil","floor","random","Game","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","moveIntervalId","targetsIntervalId","complexityIntervalId","ongoingDirection","loopCounter","complexity","pixels","targets","direction","RIGHT","gameOver","handleKeyDown","bind","assertThisInitialized","document","addEventListener","react","PIXEL_SIZE","map","px","idx","components_Pixel_Pixel","key","tg","components_TargetPixel_TargetPixel","components_Complexity_Complexity","event","preventDefault","_mapEventToDirection","correct","UP","reverse","DOWN","LEFT","_initFirstPixel","setIntervals","toConsumableArray","unshift","setState","_this2","res","reduce","acc","currentPixel","current","objectSpread","previous","_movePixel","push","headPixel","_hasBorderConflict","_onGameOver","_hasSelfConflict","length","hasTargets","hitTargetIndex","_hitTheTarget","onTargetHit","_appendPixelToEnd","oldLastPixel","targetIndex","splice","window","clearInterval","removeEventListener","hedPixel","some","pixel","findIndex","nextTarget","Error","_this3","setInterval","_updateDirection","_updatePixelPositions","needsTarget","_generateValidTarget","areaSize","target","_isValidTarget","newTarget","React","App","scripts_Snake_Game","Boolean","location","hostname","match","ReactDOM","render","src_App","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.5000a370.chunk.js","sourcesContent":["import React from 'react';\nimport './Pixel.scss';\n\nfunction Pixel(props) {\n  return (\n    <div className=\"game-wrapper__pixel\" style={{top: `${props.top}px`, left: `${props.left}px`, width: `${props.size}px`, height: `${props.size}px`}}>\n    </div>\n  );\n}\n\nexport default Pixel;\n","import React from 'react';\nimport './TargetPixel.scss';\n\nfunction TargetPixel(props) {\n  return (\n    <div className=\"game-wrapper__target-pixel\" style={{top: `${props.top}px`, left: `${props.left}px`, width: `${props.size}px`, height: `${props.size}px`}}>\n    </div>\n  );\n}\n\nexport default TargetPixel;\n","import React from 'react';\nimport './Complexity.scss';\n\nfunction Complexity(props: any) {\n  const style = {\n\n  };\n  return (\n    <div className=\"game-wrapper__complexity-wrapper\" style={style}>\n      <div className=\"game-wrapper__complexity-wrapper__complexity-indicator\"/>\n    </div>\n  );\n}\n\nexport default Complexity;\n","import * as React from 'react';\nimport './Game.scss';\nimport Pixel from './components/Pixel/Pixel';\nimport TargetPixel from './components/TargetPixel/TargetPixel';\nimport Complexity from './components/Complexity/Complexity';\nimport {createPixel, createTarget} from './helpers/dataObjects';\nimport {pixelObject, targetObject} from \"../../typings/Snake/helpers/dataObjects.d\";\n\nenum DIRECTION {\n    UP = \"UP\",\n    DOWN = \"DOWN\",\n    LEFT = \"LEFT\",\n    RIGHT = \"RIGHT\"\n}\n\nconst PIXEL_SIZE = 20;\nconst AREA_SIZE = PIXEL_SIZE * 20;\n\ninterface props {\n}\n\ninterface state {\n    pixels: pixelObject[],\n    targets: targetObject[],\n    direction: DIRECTION,\n    gameOver: boolean\n}\n\nclass Game extends React.Component<props> {\n    public state: state;\n\n    private moveIntervalId: number | undefined;\n    private targetsIntervalId: number | undefined;\n    private complexityIntervalId: number | undefined;\n\n    private ongoingDirection: { correct: DIRECTION, reverse: DIRECTION } | undefined;\n    private loopCounter: number = 0;\n    private complexity: number = 1; //from 1 to 10\n\n    constructor(props: props) {\n        super(props);\n        this.state = {\n            pixels: [],\n            targets: [],\n            direction: DIRECTION.RIGHT,\n            gameOver: false\n        };\n        this.handleKeyDown = this.handleKeyDown.bind(this);\n        document.addEventListener(\"keydown\", this.handleKeyDown);\n    }\n\n    render() {\n        return [<div className={`game-wrapper ${this.state.gameOver ? 'game-wrapper--game-over' : ''}`}\n                     style={{width: `${AREA_SIZE}px`, height: `${AREA_SIZE}px`}}>\n                {this.state.pixels.map((px: pixelObject, idx: number) => <Pixel key={idx} size={PIXEL_SIZE} top={px.top}\n                                                                                left={px.left}/>)}\n                {this.state.targets.map((tg: targetObject, idx: number) => <TargetPixel key={idx} size={PIXEL_SIZE}\n                                                                                        top={tg.top} left={tg.left}/>)}\n            </div>,\n            <Complexity/>\n        ];\n    }\n\n    handleKeyDown(event: KeyboardEvent): void {\n        event.preventDefault();\n        const direction = this._mapEventToDirection(event);\n        if (direction) {\n            this.ongoingDirection = direction;\n        }\n    }\n\n    _mapEventToDirection(event: KeyboardEvent): { correct: DIRECTION, reverse: DIRECTION } | false {\n        switch (event.key) {\n            case 'ArrowUp': {\n                return {\n                    correct: DIRECTION.UP,\n                    reverse: DIRECTION.DOWN\n                };\n            }\n            case 'ArrowRight': {\n                return {\n                    correct: DIRECTION.RIGHT,\n                    reverse: DIRECTION.LEFT\n                };\n            }\n            case 'ArrowDown': {\n                return {\n                    correct: DIRECTION.DOWN,\n                    reverse: DIRECTION.UP\n                };\n            }\n            case 'ArrowLeft': {\n                return {\n                    correct: DIRECTION.LEFT,\n                    reverse: DIRECTION.RIGHT\n                };\n            }\n            default: {\n                return false\n            }\n        }\n    }\n\n    componentDidMount() {\n        this._initFirstPixel();\n        this.setIntervals();\n    }\n\n    _initFirstPixel() {\n        const pixels = [...this.state.pixels];\n        pixels.unshift(createPixel(PIXEL_SIZE));\n        pixels.unshift(createPixel(PIXEL_SIZE));\n        pixels.unshift(createPixel(PIXEL_SIZE));\n        pixels.unshift(createPixel(PIXEL_SIZE));\n        pixels.unshift(createPixel(PIXEL_SIZE));\n        pixels.unshift(createPixel(PIXEL_SIZE));\n        pixels.unshift(createPixel(PIXEL_SIZE));\n\n        this.setState({pixels});\n    }\n\n    _updatePixelPositions(): void {\n        const oldPixels = [...this.state.pixels];\n        const res = oldPixels.reduce((acc: { previous?: pixelObject, pixels: pixelObject[] }, currentPixel) => {\n            let current = {...currentPixel};\n            if (acc.previous) {\n                let previous = {...acc.previous};\n                acc.previous = {...current};\n                current = {...current, top: previous.top, left: previous.left};\n\n            } else {\n                acc.previous = {...current};\n                this._movePixel(current);\n            }\n            acc.pixels.push(current);\n            return acc;\n        }, {pixels: []});\n\n        const headPixel = res.pixels[0];\n        if (this._hasBorderConflict(headPixel)) {\n            return this._onGameOver()\n        }\n        if (this._hasSelfConflict(headPixel)) {\n            return this._onGameOver();\n        }\n        if (this.state.targets.length) {\n\n        }\n        if (this.hasTargets) {\n            const hitTargetIndex = this._hitTheTarget(headPixel);\n            if (hitTargetIndex >= 0) {\n                this.onTargetHit(hitTargetIndex);\n                this._appendPixelToEnd(res.pixels)\n            }\n        }\n        this.setState({pixels: res.pixels})\n    }\n\n    _appendPixelToEnd(pixels: pixelObject[]):void {\n        //just append the old last pixel into updated pixels (same position)\n        const oldLastPixel = this.state.pixels[this.state.pixels.length - 1];\n        pixels.push(createPixel(PIXEL_SIZE, oldLastPixel));\n    }\n\n    onTargetHit(targetIndex: number) {\n        const targets = [...this.state.targets];\n        //remove the hit target\n        targets.splice(targetIndex, 1);\n        this.setState({targets});\n    }\n\n    _updateDirection(): void {\n        if (this.ongoingDirection && this.ongoingDirection.reverse !== this.state.direction) {\n            this.setState({direction: this.ongoingDirection.correct});\n            delete this.ongoingDirection;\n        }\n    }\n\n    _onGameOver(): void {\n        this.setState({gameOver: true});\n        window.clearInterval(this.moveIntervalId);\n        window.clearInterval(this.targetsIntervalId);\n        document.removeEventListener(\"keydown\", this.handleKeyDown);\n    }\n\n    _hasBorderConflict(headPixel: pixelObject): boolean {\n        return (headPixel.top + PIXEL_SIZE > AREA_SIZE ||\n            headPixel.top < 0 ||\n            headPixel.left < 0 ||\n            headPixel.left + PIXEL_SIZE > AREA_SIZE);\n    }\n\n    _hasSelfConflict(hedPixel: pixelObject): boolean {\n        return this.state.pixels.some((pixel: pixelObject) => {\n            return pixel.top === hedPixel.top && pixel.left === hedPixel.left;\n        });\n    }\n\n    _hitTheTarget(headPixel: pixelObject): number {\n        return this.state.targets.findIndex((nextTarget: targetObject) => {\n            return nextTarget.top === headPixel.top && nextTarget.left === headPixel.left\n        });\n    }\n\n    _movePixel(pixel: pixelObject): pixelObject {\n        switch (this.state.direction) {\n            case DIRECTION.UP: {\n                pixel.top -= PIXEL_SIZE;\n                break;\n            }\n            case DIRECTION.RIGHT: {\n                pixel.left += PIXEL_SIZE;\n                break;\n            }\n            case DIRECTION.DOWN: {\n                pixel.top += PIXEL_SIZE;\n                break;\n            }\n            case DIRECTION.LEFT: {\n                pixel.left -= PIXEL_SIZE;\n                break;\n            }\n            default: {\n                throw new Error(`Unknown direction ${this.state.direction}`);\n            }\n        }\n        return pixel\n    }\n\n    setIntervals() {\n        this.moveIntervalId = window.setInterval(() => {\n            this.loopCounter++;\n            if(this.loopCounter % (10 - this.complexity) !== 0){\n                return\n            }\n            this._updateDirection();\n            this._updatePixelPositions();\n        }, 50);//todo add complexity\n\n\n        this.targetsIntervalId = window.setInterval(() => {\n            if (this.needsTarget) {\n                this.setState({targets: [...this.state.targets, this._generateValidTarget()]})\n            }\n        }, 500)\n\n        this.complexityIntervalId = window.setInterval(() => {\n            this.complexity++;\n            if(this.complexity === 9){\n                clearInterval(this.complexityIntervalId)\n            }\n        }, 2000)\n    }\n\n    _generateValidTarget(): targetObject {\n        const target = createTarget(PIXEL_SIZE, AREA_SIZE);\n        if (!this._isValidTarget(target)) {\n            return this._generateValidTarget()\n        }\n        return target;\n    }\n\n    _isValidTarget(newTarget: targetObject): boolean {\n        return !(this.state.pixels.some((pixel: pixelObject) => {\n            return pixel.top === newTarget.top && pixel.left === newTarget.left\n        }) || this.state.targets.some((target: targetObject) => {\n            return target.top === newTarget.top && target.left === newTarget.left\n        }))\n    }\n\n    get needsTarget(): boolean {\n        return Math.random() >= 0.9; //todo add complexity\n    }\n\n    get hasTargets(): boolean {\n        return !!this.state.targets.length;\n    }\n}\n\nexport default Game;\n","import {pixelObject, targetObject} from \"../../../typings/Snake/helpers/dataObjects.d\";\n\nlet initialLeft = 0;\nlet initialPixelIndex = 0;\nlet initialTargetIndex = 0;\n\nexport function createPixel(size: number, origin?: pixelObject): pixelObject {\n    return {\n        top: origin ? origin.top : 0,\n        left: origin ? origin.left : initialLeft += size,\n        _index: ++initialPixelIndex\n    }\n}\n\nexport function createTarget(size: number, areaSize: number): targetObject {\n    return {\n        top: getRandomInt(0, areaSize / size - 1) * size,\n        left: getRandomInt(0, areaSize / size - 1) * size,\n        _index: ++initialTargetIndex\n    }\n}\n\n\nfunction getRandomInt(min: number, max: number) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n","import React from 'react';\nimport './App.css';\nimport Game from './scripts/Snake/Game';\n\nfunction App() {\n  return (\n    <div className=\"app\">\n      <Game/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}