{"version":3,"sources":["scripts/Snake/components/Pixel/Pixel.js","scripts/Snake/components/TargetPixel/TargetPixel.js","scripts/Snake/components/Complexity/Complexity.tsx","scripts/Snake/Game.tsx","scripts/Snake/helpers/dataObjects.tsx","App.js","serviceWorker.js","index.js"],"names":["Pixel","props","react_default","a","createElement","className","style","top","concat","left","width","size","height","TargetPixel","Complexity","DIRECTION","initialLeft","initialPixelIndex","initialTargetIndex","createPixel","origin","_index","getRandomInt","min","max","Math","ceil","floor","random","Game","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","moveIntervalId","targetsIntervalId","ongoingDirection","loopCounter","complexity","pixels","targets","direction","RIGHT","gameOver","handleKeyDown","bind","assertThisInitialized","document","addEventListener","react","PIXEL_SIZE","map","px","idx","components_Pixel_Pixel","key","tg","components_TargetPixel_TargetPixel","components_Complexity_Complexity","event","preventDefault","_mapEventToDirection","correct","UP","reverse","DOWN","LEFT","_initFirstPixel","setIntervals","toConsumableArray","unshift","setState","_this2","res","reduce","acc","currentPixel","current","objectSpread","previous","_movePixel","push","headPixel","_hasBorderConflict","_onGameOver","_hasSelfConflict","length","hasTargets","hitTargetIndex","_hitTheTarget","onTargetHit","_appendPixelToEnd","oldLastPixel","targetIndex","splice","window","clearInterval","removeEventListener","hedPixel","some","pixel","findIndex","nextTarget","Error","_this3","setInterval","_updateDirection","_updatePixelPositions","needsTarget","_generateValidTarget","areaSize","target","_isValidTarget","newTarget","React","App","scripts_Snake_Game","Boolean","location","hostname","match","ReactDOM","render","src_App","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.d1236134.chunk.js","sourcesContent":["import React from 'react';\nimport './Pixel.scss';\n\nfunction Pixel(props) {\n  return (\n    <div className=\"game-wrapper__pixel\" style={{top: `${props.top}px`, left: `${props.left}px`, width: `${props.size}px`, height: `${props.size}px`}}>\n    </div>\n  );\n}\n\nexport default Pixel;\n","import React from 'react';\nimport './TargetPixel.scss';\n\nfunction TargetPixel(props) {\n  return (\n    <div className=\"game-wrapper__target-pixel\" style={{top: `${props.top}px`, left: `${props.left}px`, width: `${props.size}px`, height: `${props.size}px`}}>\n    </div>\n  );\n}\n\nexport default TargetPixel;\n","import React from 'react';\nimport './Complexity.scss';\n\nfunction Complexity(props: any) {\n  const style = {\n\n  };\n  return (\n    <div className=\"game-wrapper__complexity-wrapper\" style={style}>\n      <div className=\"game-wrapper__complexity-wrapper__complexity-indicator\"/>\n    </div>\n  );\n}\n\nexport default Complexity;\n","import * as React from 'react';\nimport './Game.scss';\nimport Pixel from './components/Pixel/Pixel';\nimport TargetPixel from './components/TargetPixel/TargetPixel';\nimport Complexity from './components/Complexity/Complexity';\nimport {createPixel, createTarget} from './helpers/dataObjects';\nimport {pixelObject, targetObject} from \"../../typings/Snake/helpers/dataObjects.d\";\n\nenum DIRECTION {\n    UP = \"UP\",\n    DOWN = \"DOWN\",\n    LEFT = \"LEFT\",\n    RIGHT = \"RIGHT\"\n}\n\nconst PIXEL_SIZE = 20;\nconst AREA_SIZE = PIXEL_SIZE * 20;\n\ninterface props {\n}\n\ninterface state {\n    pixels: pixelObject[],\n    targets: targetObject[],\n    direction: DIRECTION,\n    gameOver: boolean\n}\n\nclass Game extends React.Component<props> {\n    public state: state;\n    private moveIntervalId: number | undefined;\n    private targetsIntervalId: number | undefined;\n    private ongoingDirection: { correct: DIRECTION, reverse: DIRECTION } | undefined;\n    private loopCounter: number = 0;\n    private complexity: number = 1; //from 1 to 10\n\n    constructor(props: props) {\n        super(props);\n        this.state = {\n            pixels: [],\n            targets: [],\n            direction: DIRECTION.RIGHT,\n            gameOver: false\n        };\n        this.handleKeyDown = this.handleKeyDown.bind(this);\n        document.addEventListener(\"keydown\", this.handleKeyDown);\n    }\n\n    render() {\n        return [<div className={`game-wrapper ${this.state.gameOver ? 'game-wrapper--game-over' : ''}`}\n                     style={{width: `${AREA_SIZE}px`, height: `${AREA_SIZE}px`}}>\n                {this.state.pixels.map((px: pixelObject, idx: number) => <Pixel key={idx} size={PIXEL_SIZE} top={px.top}\n                                                                                left={px.left}/>)}\n                {this.state.targets.map((tg: targetObject, idx: number) => <TargetPixel key={idx} size={PIXEL_SIZE}\n                                                                                        top={tg.top} left={tg.left}/>)}\n            </div>,\n            <Complexity/>\n        ];\n    }\n\n    handleKeyDown(event: KeyboardEvent): void {\n        event.preventDefault();\n        const direction = this._mapEventToDirection(event);\n        if (direction) {\n            this.ongoingDirection = direction;\n        }\n    }\n\n    _mapEventToDirection(event: KeyboardEvent): { correct: DIRECTION, reverse: DIRECTION } | false {\n        switch (event.key) {\n            case 'ArrowUp': {\n                return {\n                    correct: DIRECTION.UP,\n                    reverse: DIRECTION.DOWN\n                };\n            }\n            case 'ArrowRight': {\n                return {\n                    correct: DIRECTION.RIGHT,\n                    reverse: DIRECTION.LEFT\n                };\n            }\n            case 'ArrowDown': {\n                return {\n                    correct: DIRECTION.DOWN,\n                    reverse: DIRECTION.UP\n                };\n            }\n            case 'ArrowLeft': {\n                return {\n                    correct: DIRECTION.LEFT,\n                    reverse: DIRECTION.RIGHT\n                };\n            }\n            default: {\n                return false\n            }\n        }\n    }\n\n    componentDidMount() {\n        this._initFirstPixel();\n        this.setIntervals();\n    }\n\n    _initFirstPixel() {\n        const pixels = [...this.state.pixels];\n        pixels.unshift(createPixel(PIXEL_SIZE));\n        pixels.unshift(createPixel(PIXEL_SIZE));\n        pixels.unshift(createPixel(PIXEL_SIZE));\n        pixels.unshift(createPixel(PIXEL_SIZE));\n        pixels.unshift(createPixel(PIXEL_SIZE));\n        pixels.unshift(createPixel(PIXEL_SIZE));\n        pixels.unshift(createPixel(PIXEL_SIZE));\n\n        this.setState({pixels});\n    }\n\n    _updatePixelPositions(): void {\n        const oldPixels = [...this.state.pixels];\n        const res = oldPixels.reduce((acc: { previous?: pixelObject, pixels: pixelObject[] }, currentPixel) => {\n            let current = {...currentPixel};\n            if (acc.previous) {\n                let previous = {...acc.previous};\n                acc.previous = {...current};\n                current = {...current, top: previous.top, left: previous.left};\n\n            } else {\n                acc.previous = {...current};\n                this._movePixel(current);\n            }\n            acc.pixels.push(current);\n            return acc;\n        }, {pixels: []});\n\n        const headPixel = res.pixels[0];\n        if (this._hasBorderConflict(headPixel)) {\n            return this._onGameOver()\n        }\n        if (this._hasSelfConflict(headPixel)) {\n            return this._onGameOver();\n        }\n        if (this.state.targets.length) {\n\n        }\n        if (this.hasTargets) {\n            const hitTargetIndex = this._hitTheTarget(headPixel);\n            if (hitTargetIndex >= 0) {\n                this.onTargetHit(hitTargetIndex);\n                this._appendPixelToEnd(res.pixels)\n            }\n        }\n        this.setState({pixels: res.pixels})\n    }\n\n    _appendPixelToEnd(pixels: pixelObject[]):void {\n        //just append the old last pixel into updated pixels (same position)\n        const oldLastPixel = this.state.pixels[this.state.pixels.length - 1];\n        pixels.push(createPixel(PIXEL_SIZE, oldLastPixel));\n    }\n\n    onTargetHit(targetIndex: number) {\n        const targets = [...this.state.targets];\n        //remove the hit target\n        targets.splice(targetIndex, 1);\n        this.setState({targets});\n    }\n\n    _updateDirection(): void {\n        if (this.ongoingDirection && this.ongoingDirection.reverse !== this.state.direction) {\n            this.setState({direction: this.ongoingDirection.correct});\n            delete this.ongoingDirection;\n        }\n    }\n\n    _onGameOver(): void {\n        this.setState({gameOver: true});\n        window.clearInterval(this.moveIntervalId);\n        window.clearInterval(this.targetsIntervalId);\n        document.removeEventListener(\"keydown\", this.handleKeyDown);\n    }\n\n    _hasBorderConflict(headPixel: pixelObject): boolean {\n        return (headPixel.top + PIXEL_SIZE > AREA_SIZE ||\n            headPixel.top < 0 ||\n            headPixel.left < 0 ||\n            headPixel.left + PIXEL_SIZE > AREA_SIZE);\n    }\n\n    _hasSelfConflict(hedPixel: pixelObject): boolean {\n        return this.state.pixels.some((pixel: pixelObject) => {\n            return pixel.top === hedPixel.top && pixel.left === hedPixel.left;\n        });\n    }\n\n    _hitTheTarget(headPixel: pixelObject): number {\n        return this.state.targets.findIndex((nextTarget: targetObject) => {\n            return nextTarget.top === headPixel.top && nextTarget.left === headPixel.left\n        });\n    }\n\n    _movePixel(pixel: pixelObject): pixelObject {\n        switch (this.state.direction) {\n            case DIRECTION.UP: {\n                pixel.top -= PIXEL_SIZE;\n                break;\n            }\n            case DIRECTION.RIGHT: {\n                pixel.left += PIXEL_SIZE;\n                break;\n            }\n            case DIRECTION.DOWN: {\n                pixel.top += PIXEL_SIZE;\n                break;\n            }\n            case DIRECTION.LEFT: {\n                pixel.left -= PIXEL_SIZE;\n                break;\n            }\n            default: {\n                throw new Error(`Unknown direction ${this.state.direction}`);\n            }\n        }\n        return pixel\n    }\n\n    setIntervals() {\n        this.moveIntervalId = window.setInterval(() => {\n            this.loopCounter++;\n            if(this.loopCounter % (10 - this.complexity) !== 0){\n                return\n            }\n            this._updateDirection();\n            this._updatePixelPositions();\n        }, 50);//todo add complexity\n\n\n        this.targetsIntervalId = window.setInterval(() => {\n            if (this.needsTarget) {\n                this.setState({targets: [...this.state.targets, this._generateValidTarget()]})\n            }\n        }, 500)\n    }\n\n    _generateValidTarget(): targetObject {\n        const target = createTarget(PIXEL_SIZE, AREA_SIZE);\n        if (!this._isValidTarget(target)) {\n            return this._generateValidTarget()\n        }\n        return target;\n    }\n\n    _isValidTarget(newTarget: targetObject): boolean {\n        return !(this.state.pixels.some((pixel: pixelObject) => {\n            return pixel.top === newTarget.top && pixel.left === newTarget.left\n        }) || this.state.targets.some((target: targetObject) => {\n            return target.top === newTarget.top && target.left === newTarget.left\n        }))\n    }\n\n    get needsTarget(): boolean {\n        return Math.random() >= 0.9; //todo add complexity\n    }\n\n    get hasTargets(): boolean {\n        return !!this.state.targets.length;\n    }\n}\n\nexport default Game;\n","import {pixelObject, targetObject} from \"../../../typings/Snake/helpers/dataObjects.d\";\n\nlet initialLeft = 0;\nlet initialPixelIndex = 0;\nlet initialTargetIndex = 0;\n\nexport function createPixel(size: number, origin?: pixelObject): pixelObject {\n    return {\n        top: origin ? origin.top : 0,\n        left: origin ? origin.left : initialLeft += size,\n        _index: ++initialPixelIndex\n    }\n}\n\nexport function createTarget(size: number, areaSize: number): targetObject {\n    return {\n        top: getRandomInt(0, areaSize / size - 1) * size,\n        left: getRandomInt(0, areaSize / size - 1) * size,\n        _index: ++initialTargetIndex\n    }\n}\n\n\nfunction getRandomInt(min: number, max: number) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n","import React from 'react';\nimport './App.css';\nimport Game from './scripts/Snake/Game';\n\nfunction App() {\n  return (\n    <div className=\"app\">\n      <Game/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}